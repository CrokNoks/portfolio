---
title: "React-Admin : Formulaires Avanc√©s (Wizards, Uploads, Champs conditionnels)"
description: "Passez au niveau sup√©rieur dans la cr√©ation de formulaires React-Admin avec des formulaires multi-√©tapes (wizards), la gestion des uploads de fichiers et les champs conditionnels."
category: "techniques"
tags: ["React", "React-Admin", "Forms", "Wizards", "Uploads", "Conditional Fields"]
publishedAt: "2025-02-20"
featured: true
author: "Lucas GUERRIER"
image: "/blog/react-admin-forms.svg"
series: "react-admin-mastery"
episode: 6
---

# React-Admin : Formulaires Avanc√©s (Wizards, Uploads, Champs conditionnels)

Les formulaires sont au c≈ìur de toute application d'administration. Si React-Admin brille par sa simplicit√© avec `<SimpleForm>` et `<TabbedForm>`, les applications du monde r√©el exigent souvent des interactions plus complexes.

Dans cet article, nous allons explorer trois techniques avanc√©es pour construire des formulaires puissants et intuitifs :
1.  **Formulaires Multi-√©tapes (Wizards)** : Pour guider l'utilisateur √† travers des processus de saisie complexes.
2.  **Gestion des Uploads de Fichiers** : Pour permettre aux utilisateurs d'envoyer des fichiers (images, documents) via vos formulaires.
3.  **Champs Conditionnels et D√©pendants** : Pour cr√©er des formulaires dynamiques qui s'adaptent en temps r√©el aux choix de l'utilisateur.

<TechStack 
  technologies={[
    { name: "React-Admin", color: "#ff6358" },
    { name: "TypeScript", color: "#3178c6" },
    { name: "Material-UI", color: "#0081cb" }
  ]}
/>

## üßô‚Äç‚ôÇÔ∏è Partie 1 : Formulaires Multi-√©tapes (Wizards)

Un formulaire long et complexe peut √™tre intimidant. Le diviser en √©tapes logiques, ou "wizard", am√©liore consid√©rablement l'exp√©rience utilisateur.

La strat√©gie consiste √† utiliser un √©tat local pour suivre l'√©tape actuelle et √† afficher les champs de mani√®re conditionnelle.

### Exemple : Cr√©ation d'un Produit en 3 √âtapes

Imaginons un formulaire de cr√©ation de produit avec trois √©tapes : "Informations de base", "M√©dia", et "Inventaire".

```jsx
// src/products/ProductCreate.tsx
import React, { useState } from 'react';
import { Create, SimpleForm, TextInput, NumberInput, SaveButton, Toolbar } from 'react-admin';
import { Stepper, Step, StepLabel, Button, Box, Typography } from '@mui/material';

const steps = ['Informations de base', 'M√©dia', 'Inventaire'];

const ProductCreateToolbar = (props) => (
    <Toolbar {...props}>
        <SaveButton />
    </Toolbar>
);

const ProductCreate = () => {
    const [activeStep, setActiveStep] = useState(0);

    const handleNext = () => setActiveStep(prev => prev + 1);
    const handleBack = () => setActiveStep(prev => prev - 1);

    return (
        <Create>
            <SimpleForm toolbar={<ProductCreateToolbar />}>
                <Stepper activeStep={activeStep} sx={{ mb: 3 }}>
                    {steps.map(label => (
                        <Step key={label}><StepLabel>{label}</StepLabel></Step>
                    ))}
                </Stepper>

                {/* √âtape 1: Informations de base */}
                {activeStep === 0 && (
                    <Box>
                        <Typography variant="h6">Informations de base</Typography>
                        <TextInput source="name" validate={required()} fullWidth />
                        <TextInput source="description" multiline fullWidth />
                    </Box>
                )}

                {/* √âtape 2: M√©dia */}
                {activeStep === 1 && (
                    <Box>
                        <Typography variant="h6">M√©dia</Typography>
                        <TextInput source="imageUrl" label="URL de l'image" fullWidth />
                        <TextInput source="thumbnailUrl" label="URL de la miniature" fullWidth />
                    </Box>
                )}

                {/* √âtape 3: Inventaire */}
                {activeStep === 2 && (
                    <Box>
                        <Typography variant="h6">Inventaire</Typography>
                        <NumberInput source="stock" validate={required()} />
                        <NumberInput source="price" validate={required()} />
                    </Box>
                )}

                <Box display="flex" justifyContent="space-between" mt={3}>
                    <Button onClick={handleBack} disabled={activeStep === 0}>
                        Pr√©c√©dent
                    </Button>
                    <Button variant="contained" onClick={handleNext} disabled={activeStep === steps.length - 1}>
                        Suivant
                    </Button>
                </Box>
            </SimpleForm>
        </Create>
    );
};

export default ProductCreate;
```

<Callout type="tip">
**UX Tip** : Le composant `<Stepper>` de Material-UI fournit un retour visuel crucial √† l'utilisateur sur sa progression, r√©duisant ainsi la charge cognitive.
</Callout>

## üì§ Partie 2 : Gestion des Uploads de Fichiers

Le composant `<FileInput>` de React-Admin est le point de d√©part, mais la magie op√®re r√©ellement dans votre `dataProvider`.

Lorsque vous utilisez `<FileInput>`, React-Admin passe un objet `File` √† la m√©thode `create` ou `update` de votre `dataProvider`. C'est √† vous de d√©cider comment le traiter.

### Sc√©nario : Upload d'une Image de Profil

1.  **Le Formulaire**

```jsx
// src/users/UserEdit.tsx
import { Edit, SimpleForm, TextInput, FileInput, ImageField } from 'react-admin';

export const UserEdit = () => (
    <Edit>
        <SimpleForm>
            <TextInput source="name" />
            <FileInput source="avatar" label="Avatar" accept="image/*">
                <ImageField source="src" title="title" />
            </FileInput>
        </SimpleForm>
    </Edit>
);
```
Le composant `<ImageField>` √† l'int√©rieur de `<FileInput>` sert √† pr√©visualiser l'image.

2.  **La Logique dans le `dataProvider`**

Votre `dataProvider` doit intercepter le champ `avatar`, l'envoyer √† votre service de stockage (S3, Firebase Storage, ou votre propre backend), puis remplacer l'objet `File` par l'URL retourn√©e avant d'enregistrer le reste des donn√©es de l'utilisateur.

```typescript
// src/dataProvider.ts
const dataProvider = {
    // ... autres m√©thodes

    update: async (resource, params) => {
        if (resource === 'users' && params.data.avatar && params.data.avatar.rawFile instanceof File) {
            const newAvatar = params.data.avatar;
            const formData = new FormData();
            formData.append('file', newAvatar.rawFile);

            // 1. Uploader le fichier vers votre API/service de stockage
            const response = await fetch('https://myapi.com/upload', {
                method: 'POST',
                body: formData,
            });
            const { url: uploadedUrl } = await response.json();

            // 2. Mettre √† jour l'enregistrement de l'utilisateur avec l'URL de l'image
            const updatedUserData = {
                ...params.data,
                avatarUrl: uploadedUrl, // Votre backend attend `avatarUrl`
                avatar: undefined, // Nettoyer l'objet FileInput
            };

            return httpClient(`${apiUrl}/${resource}/${params.id}`, {
                method: 'PUT',
                body: JSON.stringify(updatedUserData),
            }).then(({ json }) => ({ data: json }));
        }

        // Comportement par d√©faut pour les autres mises √† jour
        return httpClient(`${apiUrl}/${resource}/${params.id}`, {
            method: 'PUT',
            body: JSON.stringify(params.data),
        }).then(({ json }) => ({ data: json }));
    },
};
```

<Callout type="warning">
**Important** : Cette logique doit √™tre adapt√©e √† votre backend. Certains backends permettent d'envoyer des donn√©es `multipart/form-data` contenant √† la fois le fichier et les autres champs, ce qui simplifie le processus en une seule requ√™te.
</Callout>

## ‚õìÔ∏è Partie 3 : Champs Conditionnels avec `<FormDataConsumer>`

`<FormDataConsumer>` est un composant de type "render prop" qui vous donne acc√®s √† toutes les donn√©es du formulaire actuel. C'est l'outil parfait pour cr√©er des formulaires dynamiques.

### Exemple : Afficher un champ "Autre"

Imaginons un champ `category`. Si l'utilisateur choisit "Autre", nous voulons afficher un champ de texte pour qu'il puisse sp√©cifier la cat√©gorie.

```jsx
// Dans un formulaire de produit
import { SelectInput, TextInput, FormDataConsumer } from 'react-admin';

const categories = [
    { id: 'tech', name: 'Technologie' },
    { id: 'books', name: 'Livres' },
    { id: 'other', name: 'Autre' },
];

<SelectInput source="category" choices={categories} />

<FormDataConsumer>
    {({ formData, ...rest }) => formData.category === 'other' &&
        <TextInput source="otherCategory" label="Pr√©cisez la cat√©gorie" {...rest} />
    }
</FormDataConsumer>
```
Le `...rest` est crucial : il propage les props n√©cessaires (comme `id`, `resource`) de `<FormDataConsumer>` au `TextInput`.

### Exemple : Champs D√©pendants

On peut aussi cr√©er des d√©pendances entre plusieurs `SelectInput`.

```jsx
// Dans un formulaire de commande
import { SelectInput, FormDataConsumer } from 'react-admin';

const countries = [
    { id: 'fr', name: 'France' },
    { id: 'us', name: '√âtats-Unis' },
];

const citiesByCountry = {
    fr: [
        { id: 'paris', name: 'Paris' },
        { id: 'lyon', name: 'Lyon' },
    ],
    us: [
        { id: 'ny', name: 'New York' },
        { id: 'sf', name: 'San Francisco' },
    ],
};

<SelectInput source="country" choices={countries} />

<FormDataConsumer>
    {({ formData, ...rest }) => formData.country &&
        <SelectInput
            source="city"
            choices={citiesByCountry[formData.country]}
            {...rest}
        />
    }
</FormDataConsumer>
```

## ‚ú® Conclusion

Les formulaires de React-Admin sont bien plus que de simples conteneurs de champs. En ma√Ætrisant ces trois techniques avanc√©es, vous pouvez transformer vos formulaires en exp√©riences utilisateur riches et guid√©es :
-   Les **Wizards** d√©composent la complexit√© et r√©duisent la friction pour l'utilisateur.
-   La gestion des **Uploads de Fichiers**, bien que n√©cessitant une logique c√¥t√© `dataProvider`, est essentielle pour de nombreuses applications.
-   Le `<FormDataConsumer>` ouvre la porte √† des **formulaires dynamiques et intelligents** qui r√©agissent en temps r√©el.

En combinant ces outils, vous √™tes √©quip√© pour construire des interfaces de saisie qui non seulement fonctionnent parfaitement mais sont aussi un plaisir √† utiliser.
