---
title: "React-Admin : Optimisation des Performances pour Grosses Applications"
description: "Votre application React-Admin est lente ? D√©couvrez des techniques essentielles pour optimiser les listes, le rendu des composants et le data fetching afin de garder votre admin rapide et r√©active."
category: "techniques"
tags: ["React", "React-Admin", "Performance", "Optimization", "React.memo", "Lazy Loading"]
publishedAt: "2025-02-22"
featured: true
author: "Lucas GUERRIER"
image: "/blog/react-admin-performance.svg"
series: "react-admin-mastery"
episode: 8
---

# React-Admin : Optimisation des Performances pour Grosses Applications

React-Admin est incroyablement rapide pour d√©marrer, mais √† mesure que votre application grandit, avec des milliers d'enregistrements et des interfaces complexes, la performance peut devenir un probl√®me. Une interface d'administration lente est frustrante et contre-productive.

Heureusement, React-Admin et l'√©cosyst√®me React offrent de nombreux outils pour identifier et corriger les goulots d'√©tranglement.

Cet article est une checklist pratique pour optimiser votre application :
1.  **Optimiser l'affichage des listes** : La source de lenteur n¬∞1.
2.  **Rationaliser le rendu des composants** et le data fetching.
3.  **All√©ger le poids de votre application** avec le lazy loading.
4.  **Diagnostiquer les probl√®mes** avec les bons outils.

<TechStack 
  technologies={[
    { name: "React-Admin", color: "#ff6358" },
    { name: "React.memo", color: "#61dafb" },
    { name: "React.lazy", color: "#61dafb" },
    { name: "Web Vitals", color: "#333" }
  ]}
/>

## üê¢ Partie 1 : Optimiser les Listes (`<Datagrid>`)

Une liste affichant des centaines de lignes avec de nombreuses colonnes est la recette parfaite pour une interface lente. Chaque interaction peut provoquer des re-renders co√ªteux.

### Solution 1 : `React.memo` sur les Champs Complexes

Si vous avez des `Field` personnalis√©s ou des champs qui effectuent des calculs, enveloppez-les dans `React.memo`. Cela emp√™chera leur re-render si leurs props n'ont pas chang√©, m√™me si la ligne parente se met √† jour.

```tsx
// src/fields/MyCustomField.tsx
import React from 'react';
import { useRecordContext } from 'react-admin';

const MyCustomField = ({ source }) => {
    const record = useRecordContext();
    // ... calculs co√ªteux
    return <span>{/* ... */}</span>;
};

// Enveloppez le composant dans React.memo √† l'export
export default React.memo(MyCustomField);
```
**Quand l'utiliser ?** Sur les champs qui sont purs (m√™me props = m√™me rendu) et qui apparaissent dans de longues listes.

### Solution 2 : D√©sactiver les `bulkActionButtons`

Un gain simple et rapide si vous n'utilisez pas les actions de masse (les cases √† cocher sur chaque ligne).

```jsx
// Dans votre composant List
<List {...props}>
    <Datagrid bulkActionButtons={false}>
        {/* ... */}
    </Datagrid>
</List>
```
Cela supprime les `Checkbox` de chaque ligne, all√©geant le DOM et les re-renders.

### Solution 3 : La Virtualisation des Listes (pour les cas extr√™mes)

Si vous devez absolument afficher des centaines de lignes √† la fois, la virtualisation est la solution ultime. Elle consiste √† ne rendre dans le DOM que les √©l√©ments visibles √† l'√©cran.

La biblioth√®que `ra-virtualized-list` est une excellente option pr√™te √† l'emploi pour int√©grer `react-window` avec le `<Datagrid>` de React-Admin.

```jsx
import { FixedSizeList } from 'react-window';
import { Datagrid, List, TextField } from 'react-admin';

// Ce n'est pas une int√©gration directe, mais une illustration du concept.
// L'utilisation de ra-virtualized-list est recommand√©e.
const VirtualizedDatagrid = () => {
    // ... logique pour r√©cup√©rer les donn√©es et les passer √† la liste virtualis√©e
    return (
        <FixedSizeList height={600} width="100%" itemCount={1000} itemSize={50}>
            {({ index, style }) => (
                <div style={style}>
                    {/* Affichez votre ligne de donn√©es ici */}
                    Ligne {index}
                </div>
            )}
        </FixedSizeList>
    );
}
```
<Callout type="warning">
La virtualisation est une technique avanc√©e. Avant de l'impl√©menter, assurez-vous qu'une pagination raisonnable et la m√©mo√Øsation ne suffisent pas.
</Callout>

## ‚ö° Partie 2 : Rationaliser le Data Fetching

Trop de requ√™tes, ou des requ√™tes trop lourdes, ralentissent votre application.

### `getMany` au lieu de multiples `getOne`

Dans une liste, le composant `<ReferenceField>` est tr√®s pratique, mais il effectue un appel `getOne` pour chaque ligne. Si vous avez 50 lignes, cela fait 50 requ√™tes !

React-Admin optimise cela en groupant ces appels en un seul `getMany`. Assurez-vous que votre `dataProvider` impl√©mente bien la m√©thode `getMany`.

```typescript
// dataProvider.ts
getMany: (resource, params) => {
    const query = {
        id: params.ids, // `ids` est un tableau d'IDs
    };
    const url = `${apiUrl}/${resource}?${stringify(query)}`;
    return httpClient(url).then(({ json }) => ({ data: json }));
},
```

### `<ReferenceArrayField>` vs `<ReferenceManyField>`

-   **`<ReferenceArrayField>`** : √Ä utiliser quand votre ressource principale contient un tableau d'IDs de la ressource li√©e (ex: un `post` a un `tag_ids: [1, 2, 3]`). Il fait **un seul appel `getMany`**. Tr√®s performant.
-   **`<ReferenceManyField>`** : √Ä utiliser quand la ressource li√©e contient l'ID de la ressource principale (ex: les `comments` ont un `post_id`). Il fait **un appel `getList`**. Moins performant si vous l'utilisez dans une liste d'√©l√©ments.

**R√®gle d'or :** Pour afficher des relations dans une liste, privil√©giez les approches qui m√®nent √† un appel `getMany` plut√¥t qu'√† de multiples `getOne` ou `getList`.

## üì¶ Partie 3 : All√©ger le Poids de l'Application

Une application plus l√©g√®re se charge plus vite.

### `React.lazy` pour les Ressources

Votre utilisateur n'a pas besoin du code de la section "Facturation" s'il est sur la page "Utilisateurs". Utilisez `React.lazy` pour ne charger le code d'une ressource que lorsque l'utilisateur y acc√®de.

```jsx
// App.tsx
import React, { lazy, Suspense } from 'react';
import { Admin, Resource, Layout } from 'react-admin';

const PostList = lazy(() => import('./posts/PostList'));
const UserList = lazy(() => import('./users/UserList'));

const MyAdmin = () => (
    <Admin dataProvider={dataProvider}>
        <Suspense fallback={<Layout />}>
            <Resource name="posts" list={PostList} />
            <Resource name="users" list={UserList} />
        </Suspense>
    </Admin>
);
```
`Suspense` permet d'afficher un fallback (comme le layout vide) pendant le chargement du chunk de code.

## üïµÔ∏è‚Äç‚ôÇÔ∏è Partie 4 : Diagnostiquer les Probl√®mes

On ne peut optimiser que ce que l'on mesure.

### 1. Le Profiler des React DevTools

C'est votre meilleur ami. Il vous permet d'enregistrer les interactions et de voir exactement quels composants se re-rendent, pourquoi, et combien de temps cela prend.
-   Activez l'enregistrement.
-   Effectuez une action dans votre app (ex: trier une colonne).
-   Arr√™tez l'enregistrement.
-   Analysez le "flamegraph" : les barres larges et jaunes sont vos coupables. Cliquez dessus pour voir pourquoi elles se sont re-rendues.

### 2. `@next/bundle-analyzer`

Si vous utilisez Next.js, cet outil est indispensable pour visualiser la taille de vos bundles JavaScript. Il vous aide √† identifier les grosses d√©pendances que vous pourriez vouloir remplacer ou charger dynamiquement.

```js
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({});
```
Lancez `ANALYZE=true npm run build` pour g√©n√©rer le rapport.

## ‚ú® Conclusion

La performance n'est pas une r√©flexion apr√®s coup, mais une caract√©ristique essentielle d'une bonne application. Pour garder votre application React-Admin rapide :

1.  **M√©mo√Øsez** les composants co√ªteux dans vos listes.
2.  **Optimisez vos strat√©gies de data fetching** pour minimiser les requ√™tes.
3.  **Chargez le code √† la demande** avec `React.lazy`.
4.  **Profilez, mesurez, et analysez** pour trouver les vrais goulots d'√©tranglement avant d'optimiser pr√©matur√©ment.

Avec ces techniques, vous √™tes arm√© pour construire des applications d'administration qui non seulement sont puissantes et fonctionnelles, mais aussi un plaisir √† utiliser, m√™me √† grande √©chelle.
