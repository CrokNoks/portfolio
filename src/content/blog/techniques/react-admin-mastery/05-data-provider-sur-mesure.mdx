---
title: "React-Admin : Le DataProvider sur-mesure (API custom, GraphQL)"
description: "Apprenez √† cr√©er et adapter votre DataProvider React-Admin pour interagir avec des APIs REST non-standard ou des services GraphQL complexes."
category: "techniques"
tags: ["React", "React-Admin", "DataProvider", "API", "REST", "GraphQL", "Custom"]
publishedAt: "2025-02-18"
featured: true
author: "Lucas GUERRIER"
image: "/blog/react-admin-data-provider.svg"
series: "react-admin-mastery"
episode: 5
---

# React-Admin : Le DataProvider sur-mesure (API custom, GraphQL)

Le `dataProvider` est le c≈ìur de l'interaction entre votre application React-Admin et votre backend. C'est lui qui traduit les requ√™tes de l'interface d'administration (lister, cr√©er, modifier, supprimer) en requ√™tes API et vice-versa.

Si les `dataProviders` existants (`ra-data-json-server`, `ra-data-simple-rest`) suffisent pour de nombreux cas, la r√©alit√© des projets implique souvent des APIs avec des conventions sp√©cifiques ou l'utilisation de GraphQL. C'est l√† qu'un `dataProvider` sur-mesure devient indispensable.

Dans cet article, nous allons voir comment :
1.  Comprendre l'interface du `dataProvider`.
2.  Construire un `dataProvider` personnalis√© pour une **API REST non-standard**.
3.  D√©velopper un `dataProvider` pour un **service GraphQL**.

<TechStack 
  technologies={[
    { name: "React-Admin", color: "#ff6358" },
    { name: "TypeScript", color: "#3178c6" },
    { name: "REST API", color: "#2E8B57" },
    { name: "GraphQL", color: "#E10098" }
  ]}
/>

## üéØ L'Interface du `dataProvider` : Votre Contrat avec l'API

Un `dataProvider` React-Admin doit impl√©menter une s√©rie de m√©thodes, chacune correspondant √† un type d'op√©ration CRUD ou de r√©cup√©ration de donn√©es. Chaque m√©thode doit retourner une `Promise`.

```typescript
// src/customDataProvider.ts
import { DataProvider } from 'react-admin';
import { fetchUtils } from 'react-admin';

const apiUrl = 'https://my-custom-api.com';
const httpClient = fetchUtils.fetchJson; // Ou un httpClient personnalis√© pour l'auth JWT

export const customDataProvider: DataProvider = {
    getList: (resource, params) => { /* ... */ },
    getOne: (resource, params) => { /* ... */ },
    getMany: (resource, params) => { /* ... */ },
    getManyReference: (resource, params) => { /* ... */ },
    create: (resource, params) => { /* ... */ },
    update: (resource, params) => { /* ... */ },
    updateMany: (resource, params) => { /* ... */ },
    delete: (resource, params) => { /* ... */ },
    deleteMany: (resource, params) => { /* ... */ },
};
```

Chacune de ces m√©thodes re√ßoit deux arguments :
-   `resource`: Le nom de la ressource (`'posts'`, `'users'`, etc.).
-   `params`: Un objet contenant les param√®tres sp√©cifiques √† l'op√©ration (filtres, pagination, donn√©es √† cr√©er/modifier, etc.).

Et doit retourner un `Promise` d'un objet avec une structure sp√©cifique (`{ data: [], total: 0 }` pour `getList`, `{ data: {} }` pour `getOne`, `create`, `update`, etc.).

<Callout type="info">
Pour une impl√©mentation compl√®te de chaque m√©thode et le format des retours attendus, consultez la <a href="https://marmelab.com/react-admin/DataProviders.html" target="_blank">documentation officielle du `dataProvider`</a>.
</Callout>

## üöÄ Partie 1 : DataProvider pour une API REST Non-Standard

Imaginons une API REST dont les conventions de pagination et de tri diff√®rent de `ra-data-simple-rest`.

**Conventions de notre API non-standard :**
-   **Pagination** : Utilise `_page` et `_pageSize` au lieu de `_start` et `_end` dans les param√®tres de requ√™te.
-   **Tri** : Utilise `_sortField` et `_sortOrder` au lieu de `_sort` et `_order`.
-   **Filtres** : Supporte des filtres imbriqu√©s pour les relations (ex: `author.name=john`).
-   **R√©ponse `getList`** : Retourne les donn√©es directement dans un tableau, avec le nombre total d'√©l√©ments dans un en-t√™te `X-Total-Count`.

### 1. `getList` : Adapter Pagination et Tri

```typescript
// src/customRestDataProvider.ts
import { DataProvider, fetchUtils } from 'react-admin';

const apiUrl = 'https://my-non-standard-api.com';
const httpClient = fetchUtils.fetchJson;

const customRestDataProvider: DataProvider = {
    getList: (resource, params) => {
        const { page, perPage } = params.pagination;
        const { field, order } = params.sort;
        const query: any = {
            _page: page,
            _pageSize: perPage,
            _sortField: field,
            _sortOrder: order,
            ...params.filter, // Les filtres de React-Admin
        };
        const url = `${apiUrl}/${resource}?${fetchUtils.serializeQuery(query)}`;

        return httpClient(url).then(({ headers, json }) => ({
            data: json,
            total: parseInt(headers.get('X-Total-Count') || '0', 10),
        }));
    },
    // ... autres m√©thodes
};
```

### 2. `getOne`, `create`, `update`

Ces m√©thodes sont g√©n√©ralement plus simples √† adapter car elles interagissent avec une seule ressource.

```typescript
// src/customRestDataProvider.ts
// ...
    getOne: (resource, params) =>
        httpClient(`${apiUrl}/${resource}/${params.id}`).then(({ json }) => ({
            data: json,
        })),

    create: (resource, params) =>
        httpClient(`${apiUrl}/${resource}`, {
            method: 'POST',
            body: JSON.stringify(params.data),
        }).then(({ json }) => ({
            data: { ...params.data, id: json.id }, // Assurez-vous que l'ID est retourn√©
        })),

    update: (resource, params) =>
        httpClient(`${apiUrl}/${resource}/${params.id}`, {
            method: 'PUT', // Ou PATCH selon votre API
            body: JSON.stringify(params.data),
        }).then(({ json }) => ({
            data: json,
        })),
    // ...
```

<Callout type="warning">
**Important** : Le `create` doit toujours retourner l'ID de la nouvelle ressource. Si votre API ne le renvoie pas directement, vous devrez le simuler ou le r√©cup√©rer autrement.
</Callout>

### 3. Gestion des Erreurs

Il est crucial de g√©rer les erreurs HTTP pour que React-Admin puisse afficher des messages pertinents.

```typescript
// src/customRestDataProvider.ts
// ...
const throwingHttpClient = (url, options = {}) => {
    return httpClient(url, options).then(response => {
        if (response.status < 200 || response.status >= 300) {
            return Promise.reject(new fetchUtils.HttpError(
                response.statusText,
                response.status,
                response.json
            ));
        }
        return response;
    });
};

// Utilisez throwingHttpClient au lieu de httpClient
// ...
```

## üöÄ Partie 2 : DataProvider pour GraphQL

GraphQL pr√©sente un paradigme diff√©rent des APIs REST. Au lieu de multiples endpoints, vous avez un seul endpoint et vous utilisez des requ√™tes (queries) et des mutations (mutations).

React-Admin fournit le package `ra-data-graphql` qui int√®gre le support de GraphQL. Il est souvent suffisant, mais cr√©er un `dataProvider` de z√©ro vous donne un contr√¥le total.

### 1. Configuration du Client GraphQL

Nous allons utiliser `Apollo Client` comme exemple, mais d'autres comme `Relay` ou `urql` fonctionnent aussi.

```typescript
// src/graphQLClient.ts
import { ApolloClient, InMemoryCache, HttpLink } from '@apollo/client';

const client = new ApolloClient({
    link: new HttpLink({ uri: 'https://my-graphql-api.com/graphql' }),
    cache: new InMemoryCache(),
});

export default client;
```

### 2. `getList` : R√©cup√©rer des Collections

Ici, nous devons construire une requ√™te GraphQL qui inclut la pagination, le tri et les filtres.

```typescript
// src/customGraphQLDataProvider.ts
import { DataProvider } from 'react-admin';
import gql from 'graphql-tag'; // N'oubliez pas d'installer graphql-tag
import client from './graphQLClient'; // Notre client Apollo

const customGraphQLDataProvider: DataProvider = {
    getList: async (resource, params) => {
        const { page, perPage } = params.pagination;
        const { field, order } = params.sort;
        const filter = JSON.stringify(params.filter); // Convertir les filtres en cha√Æne

        const query = gql`
            query ${resource}List($page: Int, $perPage: Int, $sortField: String, $sortOrder: String, $filter: JSON) {
                ${resource} (page: $page, perPage: $perPage, sortField: $sortField, sortOrder: $sortOrder, filter: $filter) {
                    id
                    // ... vos champs de ressource
                }
                ${resource}Count (filter: $filter)
            }
        `;

        const { data } = await client.query({
            query,
            variables: { page, perPage, sortField: field, sortOrder: order, filter },
        });

        return {
            data: data[resource],
            total: data[`${resource}Count`],
        };
    },
    // ...
};
```
<Callout type="tip">
**Bonne pratique** : GraphQL ne fournit pas toujours un `_count` pour les collections. Vous devrez peut-√™tre ajouter un champ sp√©cifique √† votre sch√©ma GraphQL (`resourceCount` dans l'exemple) pour la pagination totale.
</Callout>

### 3. `getOne` : R√©cup√©rer une Entit√© Unique

```typescript
// src/customGraphQLDataProvider.ts
// ...
    getOne: async (resource, params) => {
        const query = gql`
            query ${resource}GetOne($id: ID!) {
                ${resource} (id: $id) {
                    id
                    // ... vos champs de ressource
                }
            }
        `;
        const { data } = await client.query({
            query,
            variables: { id: params.id },
        });

        return { data: data[resource] };
    },
    // ...
```

### 4. `create` et `update` : Ex√©cuter des Mutations

```typescript
// src/customGraphQLDataProvider.ts
// ...
    create: async (resource, params) => {
        const mutation = gql`
            mutation ${resource}Create($data: ${resource}Input!) {
                create${resource} (data: $data) {
                    id
                    // ... vos champs de ressource mis √† jour
                }
            }
        `;
        const { data } = await client.mutate({
            mutation,
            variables: { data: params.data },
        });

        return { data: data[`create${resource}`] };
    },

    update: async (resource, params) => {
        const mutation = gql`
            mutation ${resource}Update($id: ID!, $data: ${resource}Input!) {
                update${resource} (id: $id, data: $data) {
                    id
                    // ... vos champs de ressource mis √† jour
                }
            }
        `;
        const { data } = await client.mutate({
            mutation,
            variables: { id: params.id, data: params.data },
        });

        return { data: data[`update${resource}`] };
    },
    // ...
};
```
<Callout type="warning">
**Attention** : Les noms des mutations (`createResource`, `updateResource`) et des types (`ResourceInput`) d√©pendent de votre sch√©ma GraphQL. Adaptez-les en cons√©quence.
</Callout>

## ‚ú® Conclusion

La cr√©ation d'un `dataProvider` sur-mesure est l'un des aspects les plus puissants de React-Admin. Elle vous offre la libert√© de connecter votre interface d'administration √† n'importe quel type de backend, qu'il s'agisse d'une API REST avec des conventions uniques ou d'un service GraphQL.

En ma√Ætrisant cette comp√©tence, vous pouvez :
-   **Int√©grer** React-Admin dans un √©cosyst√®me existant sans modifier votre backend.
-   **Optimiser** les requ√™tes pour des performances maximales.
-   **√âtendre** les fonctionnalit√©s CRUD de base avec des logiques m√©tier complexes.

Votre `dataProvider` est le pont entre votre UI et vos donn√©es. Savoir le construire vous ouvre les portes d'une personnalisation illimit√©e et d'une int√©gration parfaite avec l'infrastructure de votre choix.
