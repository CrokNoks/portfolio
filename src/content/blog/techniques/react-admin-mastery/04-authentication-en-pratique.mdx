---
title: "React-Admin : L'Authentification en Pratique (JWT, OAuth, R√¥les)"
description: "Un guide complet pour s√©curiser votre application React-Admin : impl√©mentez l'authentification JWT, le login social OAuth, et g√©rez les permissions par r√¥le."
category: "techniques"
tags: ["React", "React-Admin", "Authentication", "JWT", "OAuth", "Security"]
publishedAt: "2025-02-17"
featured: true
author: "Lucas GUERRIER"
image: "/blog/react-admin-auth.svg"
series: "react-admin-mastery"
episode: 4
---

# React-Admin : L'Authentification en Pratique (JWT, OAuth, R√¥les)

S√©curiser une interface d'administration n'est pas une option, c'est une n√©cessit√©. React-admin nous simplifie grandement la t√¢che gr√¢ce √† un syst√®me d'authentification flexible et puissant : le `authProvider`.

Dans cet article, nous allons explorer en profondeur comment impl√©menter des strat√©gies d'authentification modernes et robustes :
1.  **Authentification par Token JWT** : La m√©thode la plus courante pour les API REST.
2.  **Login Social via OAuth** : Permettre aux utilisateurs de se connecter avec leur compte Google ou GitHub.
3.  **Gestion des R√¥les et Permissions** : Contr√¥ler qui peut voir quoi et qui peut faire quoi dans votre application.

<TechStack 
  technologies={[
    { name: "React-Admin", color: "#ff6358" },
    { name: "JWT", color: "#000000" },
    { name: "OAuth 2.0", color: "#24292e" },
    { name: "TypeScript", color: "#3178c6" }
  ]}
/>

## üéØ Le `authProvider` : Le Gardien de votre Application

Le `authProvider` est un objet qui expose une interface simple pour brancher votre logique d'authentification √† React-Admin. Il suffit de le passer au composant `<Admin>`.

Voici les m√©thodes essentielles que vous devrez impl√©menter :

```typescript
// src/authProvider.ts
import { AuthProvider } from 'react-admin';

export const authProvider: AuthProvider = {
    // M√©thode appel√©e sur la page de login
    login: ({ username, password }) =>  Promise.resolve(),
    
    // M√©thode appel√©e pour d√©connecter l'utilisateur
    logout: () => Promise.resolve(),

    // M√©thode appel√©e √† chaque changement de page pour v√©rifier les erreurs (ex: 401)
    checkError: ({ status }) => Promise.resolve(),

    // M√©thode appel√©e √† chaque navigation pour v√©rifier que l'utilisateur est bien connect√©
    checkAuth: () => Promise.resolve(),

    // M√©thode pour r√©cup√©rer les permissions de l'utilisateur
    getPermissions: () => Promise.resolve(),

    // M√©thode pour r√©cup√©rer l'identit√© de l'utilisateur (id, nom, avatar)
    getIdentity: () => Promise.resolve(),
};
```

<Callout type="info">
Chaque m√©thode retourne une `Promise`. Vous devez retourner `Promise.resolve()` en cas de succ√®s et `Promise.reject()` en cas d'√©chec pour que React-Admin puisse r√©agir en cons√©quence (par exemple, rediriger vers la page de login).
</Callout>

## üîê Partie 1 : Authentification par Token JWT

C'est le sc√©nario le plus classique. L'utilisateur fournit un email/mot de passe, le backend retourne un JSON Web Token (JWT) si les identifiants sont corrects. Ce token sera ensuite envoy√© √† chaque requ√™te pour prouver l'identit√© de l'utilisateur.

### 1. Le Processus de Login

```typescript
// src/authProvider.ts
export const authProvider: AuthProvider = {
    login: async ({ username, password }) => {
        const request = new Request('https://myapi.com/authenticate', {
            method: 'POST',
            body: JSON.stringify({ email: username, password }),
            headers: new Headers({ 'Content-Type': 'application/json' }),
        });
        try {
            const response = await fetch(request);
            if (response.status < 200 || response.status >= 300) {
                throw new Error(response.statusText);
            }
            const { token } = await response.json();
            // On stocke le token dans le localStorage
            localStorage.setItem('token', token);
            return Promise.resolve();
        } catch {
            throw new Error('Email ou mot de passe incorrect');
        }
    },
    // ... autres m√©thodes
};
```

### 2. V√©rifier l'Authentification (`checkAuth`)

Cette m√©thode est appel√©e √† chaque fois que l'utilisateur navigue dans l'application. C'est ici qu'on v√©rifie la pr√©sence du token.

```typescript
// src/authProvider.ts
// ...
    checkAuth: () => {
        return localStorage.getItem('token')
            ? Promise.resolve()
            : Promise.reject();
    },
// ...
```
Si la `Promise` est rejet√©e, React-Admin redirigera automatiquement l'utilisateur vers la page de login.

### 3. D√©connexion (`logout`)

Pour d√©connecter l'utilisateur, il suffit de supprimer le token.

```typescript
// src/authProvider.ts
// ...
    logout: () => {
        localStorage.removeItem('token');
        return Promise.resolve();
    },
// ...
```

### 4. Envoyer le Token √† l'API

Votre `dataProvider` doit √™tre modifi√© pour inclure le token dans les en-t√™tes de chaque requ√™te.

```typescript
// src/dataProvider.ts
import { fetchUtils } from 'react-admin';
import simpleRestProvider from 'ra-data-simple-rest';

const httpClient = (url, options = {}) => {
    if (!options.headers) {
        options.headers = new Headers({ Accept: 'application/json' });
    }
    const token = localStorage.getItem('token');
    options.headers.set('Authorization', `Bearer ${token}`);
    return fetchUtils.fetchJson(url, options);
};

export const dataProvider = simpleRestProvider('https://myapi.com', httpClient);
```

<Callout type="warning">
**Attention** : Le `dataProvider` n'a pas acc√®s au `authProvider`. Il faut donc acc√©der directement au `localStorage` pour r√©cup√©rer le token. Assurez-vous d'√™tre coh√©rent dans la mani√®re dont vous stockez et r√©cup√©rez le token.
</Callout>

## üåê Partie 2 : Login Social avec OAuth

Permettre √† vos utilisateurs de se connecter via des services tiers comme Google ou GitHub am√©liore consid√©rablement l'exp√©rience. Le flux OAuth est plus complexe, mais le `authProvider` reste notre point d'entr√©e.

Ici, nous n'aurons pas de page de login classique. Nous aurons une page avec un simple bouton "Se connecter avec GitHub".

### 1. Un `login` diff√©rent

La m√©thode `login` ne sera pas appel√©e avec un email/password. En fait, nous n'en aurons pas besoin. Le processus de connexion sera initi√© par un composant personnalis√©.

### 2. Page de Login Personnalis√©e

```jsx
// src/MyLoginPage.tsx
import * as React from 'react';
import { Button } from '@mui/material';
import { useLogin, useNotify } from 'react-admin';

const MyLoginPage = () => {
    const login = useLogin();
    const notify = useNotify();

    const handleLogin = () => {
        // L'URL de votre backend qui initie le flux OAuth
        const oauthRedirectUrl = 'https://myapi.com/auth/github';
        
        // On redirige l'utilisateur vers GitHub
        window.location.href = oauthRedirectUrl;
    };

    return (
        <div>
            <h1>Connexion</h1>
            <Button variant="contained" onClick={handleLogin}>
                Se connecter avec GitHub
            </Button>
        </div>
    );
};

export default MyLoginPage;
```
Et on l'utilise dans `<Admin>`:
```jsx
// src/App.tsx
import { Admin } from 'react-admin';
import MyLoginPage from './MyLoginPage';

const App = () => (
    <Admin loginPage={MyLoginPage} /* ... */>
        {/* ... */}
    </Admin>
);
```

### 3. G√©rer le Callback

Apr√®s que l'utilisateur a autoris√© l'application sur GitHub, il sera redirig√© vers une URL de callback de votre application (ex: `https://myapp.com/auth-callback`). C'est sur cette page que la magie op√®re.

```jsx
// src/AuthCallback.tsx
import React, { useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import { useNotify } from 'react-admin';

const AuthCallback = () => {
    const location = useLocation();
    const notify = useNotify();

    useEffect(() => {
        const params = new URLSearchParams(location.search);
        const token = params.get('token'); // Supposons que votre backend renvoie le token en param√®tre

        if (token) {
            localStorage.setItem('token', token);
            // Redirige vers la page d'accueil de l'admin
            window.location.replace('/'); 
        } else {
            notify("Erreur d'authentification", { type: 'error' });
            window.location.replace('/login');
        }
    }, [location, notify]);

    return <div>Authentification en cours...</div>;
};

export default AuthCallback;
```
Vous devez ajouter une route pour cette page dans votre `App.tsx` en utilisant le prop `customRoutes`.

## üõ°Ô∏è Partie 3 : Gestion des R√¥les et Permissions

Savoir *qui* est connect√© est bien, mais savoir *ce qu'il a le droit de faire* est mieux.

### 1. `getPermissions`

Cette m√©thode est cruciale. Elle est appel√©e une fois apr√®s le login et le r√©sultat est mis en cache. Elle doit retourner les permissions de l'utilisateur (un r√¥le, un tableau d'actions, etc.).

```typescript
// src/authProvider.ts
import { jwtDecode } from "jwt-decode";

// ...
    getPermissions: () => {
        const token = localStorage.getItem('token');
        if (!token) {
            return Promise.reject();
        }
        // Supposons que le r√¥le est encod√© dans le token JWT
        const decodedToken: { role: string } = jwtDecode(token);
        const role = decodedToken.role;
        return Promise.resolve(role); // ex: 'admin', 'moderator', 'user'
    },
// ...
```

### 2. Utiliser les Permissions dans l'UI

React-Admin fournit le hook `usePermissions` pour acc√©der aux permissions partout dans votre application.

**Exemple : Un bouton "Supprimer" r√©serv√© aux admins.**

```jsx
// Dans une Edit view
import { DeleteButton, usePermissions } from 'react-admin';

const MyToolbar = props => {
    const { permissions } = usePermissions();
    return (
        <Toolbar {...props}>
            <SaveButton />
            {permissions === 'admin' && <DeleteButton />}
        </Toolbar>
    );
};
```

**Exemple : Une ressource visible uniquement par les admins.**

Vous pouvez passer une fonction en tant que `children` de `<Admin>` pour filtrer vos ressources.

```jsx
// src/App.tsx
import { Admin, Resource, usePermissions } from 'react-admin';

const App = () => (
    <Admin authProvider={authProvider} dataProvider={dataProvider}>
        {permissions => (
            <>
                <Resource name="posts" /* ... */ />
                <Resource name="comments" /* ... */ />
                {permissions === 'admin' && (
                    <Resource name="users" /* ... */ />
                )}
            </>
        )}
    </Admin>
);
```

## ‚ú® Conclusion

Le `authProvider` de React-Admin est une interface incroyablement puissante et flexible qui permet de s'adapter √† presque tous les syst√®mes d'authentification.

En ma√Ætrisant ses diff√©rentes m√©thodes, vous pouvez :
- Impl√©menter une authentification **JWT classique** en quelques minutes.
- Int√©grer des **logins sociaux (OAuth)** pour une meilleure exp√©rience utilisateur.
- Mettre en place une **gestion des permissions bas√©e sur les r√¥les** pour s√©curiser finement votre application.

La s√©curit√© n'est plus un obstacle, mais une fonctionnalit√© que vous pouvez modeler √† votre guise pour construire des applications d'administration robustes et professionnelles.
